# Docker Compose configuration for QR Generator
services:
  api:
    build: .
    container_name: qr_generator_api
    environment:
      - TZ=America/New_York
      # Application Configuration
      - LOG_LEVEL=${LOG_LEVEL:-INFO}
      - DEBUG=${DEBUG:-false}
      - BASE_URL=${BASE_URL:-https://10.1.6.12} # This should be your primary internal access URL
      # Security Configuration
      # NOTE: Domain allowlist removed - QR codes can now redirect to any valid HTTP/HTTPS URL
      # Database Configuration
      - PG_DATABASE_URL=${PG_DATABASE_URL:-postgresql+psycopg2://pguser:pgpassword@postgres:5432/qrdb}
      - ENVIRONMENT=production # Production environment settings
      # PostgreSQL Configuration (for app to connect to DB)
      - POSTGRES_USER=${POSTGRES_USER:-pguser}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD:-pgpassword}
      - POSTGRES_DB=${POSTGRES_DB:-qrdb}
      - POSTGRES_HOST=${POSTGRES_HOST:-postgres}
      - POSTGRES_PORT=${POSTGRES_PORT:-5432}
      # Test Database Configuration
      - TEST_POSTGRES_USER=${TEST_POSTGRES_USER:-pguser_test}
      - TEST_POSTGRES_PASSWORD=${TEST_POSTGRES_PASSWORD:-pgpassword_test}
      - TEST_POSTGRES_DB=${TEST_POSTGRES_DB:-qrdb_test}
      - TEST_POSTGRES_HOST=${TEST_POSTGRES_HOST:-postgres_test}
      - TEST_POSTGRES_PORT=${TEST_POSTGRES_PORT:-5432}
      - TEST_DATABASE_URL=${TEST_DATABASE_URL:-postgresql+psycopg2://pguser_test:pgpassword_test@postgres_test:5432/qrdb_test}
      # Cookie settings (if needed for any non-auth CSRF or future features)
      - COOKIE_DOMAIN=${COOKIE_DOMAIN:-10.1.6.12} # Align with your internal dashboard access
      # Testing Configuration
      - E2E_API_BASE_URL=${E2E_API_BASE_URL:-https://10.1.6.12}
      # Feature Flags
      - USE_NEW_QR_GENERATION_SERVICE=${USE_NEW_QR_GENERATION_SERVICE:-false}
      - USE_NEW_ANALYTICS_SERVICE=${USE_NEW_ANALYTICS_SERVICE:-false}
      - USE_NEW_VALIDATION_SERVICE=${USE_NEW_VALIDATION_SERVICE:-false}
      - CANARY_TESTING_ENABLED=${CANARY_TESTING_ENABLED:-false}
      - CANARY_PERCENTAGE=${CANARY_PERCENTAGE:-0}
      # Circuit Breaker Configuration
      - QR_GENERATION_CB_FAIL_MAX=${QR_GENERATION_CB_FAIL_MAX:-5}
      - QR_GENERATION_CB_RESET_TIMEOUT=${QR_GENERATION_CB_RESET_TIMEOUT:-60}
    volumes:
      - qr_data:/app/data
      - ./backups:/app/backups
      - qr_logs:/logs
      - ./app:/app/app # Mount entire app directory for live code changes
      - ./tests:/app/tests # Mount the top-level tests directory for E2E tests
      - ./app/scripts:/app/scripts # Mount scripts for immediate availability without rebuild (includes init.sh)
      - test_advanced_qr_images:/app/test_advanced_qr_images # Use a named volume to avoid permission issues
      - qr_codes_data:/app/app/static/assets/images/qr_codes # Use a named volume for QR codes
      - /var/run/docker.sock:/var/run/docker.sock:ro # Allow container to control Docker (for backup/restore API management)
      - ./.env:/app/.env:ro # Mount .env file for init.sh script
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped
    extra_hosts:
      - "10.1.6.12:host-gateway" # Maps the host IP to this hostname inside the container
    depends_on:
      postgres:
        condition: service_healthy
      postgres_test:
        condition: service_healthy
    labels:
      - "traefik.enable=true"
      # Define the service for Traefik.
      # The actual routing rules, entrypoints, and middlewares are now primarily in dynamic_conf.yml,
      # which will refer to this service as 'api-service'.
      - "traefik.http.services.api-service.loadbalancer.server.port=8000"
      # Optional: If you want a very low priority, Docker-provider-specific default router
      # for this service *if no rules in dynamic_conf.yml match it*.
      # This is generally not needed if dynamic_conf.yml is comprehensive.
      # - "traefik.http.routers.api-docker-catchall.rule=Host(`your-internal-docker-host.example.com`)" # Replace with a real, unique internal hostname
      # - "traefik.http.routers.api-docker-catchall.service=api-service"
      # - "traefik.http.routers.api-docker-catchall.priority=1" # Lowest priority
      # - "traefik.http.routers.api-docker-catchall.entrypoints=web"

  # PostgreSQL service (Production DB)
  postgres:
    image: postgres:15
    container_name: qr_generator_postgres
    environment:
      - POSTGRES_USER=${POSTGRES_USER:-pguser}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD:-pgpassword}
      - POSTGRES_DB=${POSTGRES_DB:-qrdb}
      - TZ=America/New_York
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-pguser} -d ${POSTGRES_DB:-qrdb}"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped
    expose: # Expose only to other containers on the same Docker network
      - "5432"

  # PostgreSQL Test service
  postgres_test:
    image: postgres:15
    container_name: qr_generator_postgres_test
    environment:
      - POSTGRES_USER=${TEST_POSTGRES_USER:-pguser_test}
      - POSTGRES_PASSWORD=${TEST_POSTGRES_PASSWORD:-pgpassword_test}
      - TEST_POSTGRES_DB=${TEST_POSTGRES_DB:-qrdb_test} # Note: This should be TEST_POSTGRES_DB
      - TZ=America/New_York
    volumes:
      - postgres_test_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${TEST_POSTGRES_USER:-pguser_test} -d ${TEST_POSTGRES_DB:-qrdb_test}"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped
    expose: # Expose only to other containers on the same Docker network
      - "5432"

  traefik:
    image: traefik:v2.10 # Or your preferred Traefik version
    container_name: qr_generator_traefik
    # Use existing configuration files instead of command-line flags
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro # So Traefik can listen to Docker events
      - ./certs:/etc/certs:ro                         # Mount your certificates
      - ./traefik.yml:/etc/traefik/traefik.yml:ro     # Static configuration
      - ./traefik_config/dynamic_conf:/etc/traefik/conf.d:ro # Dynamic configuration directory
      - ./users.htpasswd:/etc/traefik/users.htpasswd:ro # Basic Auth users file
      - traefik_logs:/logs/traefik # For Traefik's own logs, if configured in traefik.yml
    ports:
      - "80:80"       # HTTP
      - "443:443"     # HTTPS
      - "8082:8082"   # Metrics endpoint
    restart: unless-stopped
    extra_hosts:
      - "10.1.6.12:host-gateway" # Maps the host IP to this hostname inside the container
    # depends_on: # Optional: if you want api to be up for traefik to configure it, though dynamic config handles this
    #   - api

  # Prometheus service
  prometheus:
    image: prom/prometheus:v2.45.0
    container_name: qr_generator_prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
      - '--storage.tsdb.retention.time=30d'
      - '--web.enable-lifecycle'
      - '--web.external-url=https://webhost.hccc.edu/prometheus/'
      - '--web.route-prefix=/prometheus/'
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - ./alerts.yml:/etc/prometheus/alerts.yml:ro
      - prometheus_data:/prometheus
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:9090/prometheus/-/healthy"]
      interval: 30s
      timeout: 10s
      retries: 3
    labels:
      - "traefik.enable=true"
      - "traefik.http.services.prometheus-service.loadbalancer.server.port=9090"

  # Grafana service
  grafana:
    image: grafana/grafana:10.1.0
    container_name: qr_generator_grafana
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_ADMIN_PASSWORD:-admin123}
      - GF_USERS_ALLOW_SIGN_UP=false
      - GF_INSTALL_PLUGINS=
    volumes:
      - grafana_data:/var/lib/grafana
      - ./grafana/grafana.ini:/etc/grafana/grafana.ini:ro
      - ./grafana/provisioning:/etc/grafana/provisioning:ro
      - ./grafana/provisioning/dashboards:/home/grafana/dashboards:rw
    ports:
      - "3000:3000"
    restart: unless-stopped
    depends_on:
      prometheus:
        condition: service_healthy
    healthcheck:
      test: ["CMD-SHELL", "wget --no-verbose --tries=1 --spider http://localhost:3000/api/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
    labels:
      - "traefik.enable=true"
      - "traefik.http.services.grafana-service.loadbalancer.server.port=3000"

  # Loki service for log aggregation
  loki:
    image: grafana/loki:2.9.0
    container_name: qr_generator_loki
    command: -config.file=/etc/loki/local-config.yaml
    volumes:
      - ./loki/loki-config.yaml:/etc/loki/local-config.yaml:ro
      - loki_data:/loki
    ports:
      - "3100:3100"
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3100/ready"]
      interval: 30s
      timeout: 10s
      retries: 3
    labels:
      - "traefik.enable=true"
      - "traefik.http.services.loki-service.loadbalancer.server.port=3100"

  # Promtail service for log collection
  promtail:
    image: grafana/promtail:2.9.0
    container_name: qr_generator_promtail
    command: -config.file=/etc/promtail/config.yml
    volumes:
      - ./promtail/promtail-config.yaml:/etc/promtail/config.yml:ro
      - /var/log:/var/log:ro
      - /var/lib/docker/containers:/var/lib/docker/containers:ro
      - /var/run/docker.sock:/var/run/docker.sock:ro
    restart: unless-stopped
    depends_on:
      - loki

  # OAuth2 Proxy for authentication
  oauth2-proxy-qr-dashboard:
    image: quay.io/oauth2-proxy/oauth2-proxy:v7.6.0
    container_name: qr_generator_oauth2_proxy
    command: --config=/etc/oauth2-proxy/oauth2-proxy.cfg
    volumes:
      - ./oauth2-proxy:/etc/oauth2-proxy
    restart: unless-stopped
    ports:
      - "4180:4180"
    depends_on:
      - api

networks:
  default:
    name: qr_generator_network
    driver: bridge

volumes:
  qr_data:
    driver: local
  qr_logs:
    driver: local
  traefik_logs:
    driver: local
  postgres_data:
    driver: local
  postgres_test_data:
    driver: local
  prometheus_data:
    driver: local
  grafana_data:
    driver: local
  loki_data:
    driver: local
  test_advanced_qr_images:
    driver: local
  qr_codes_data:
    driver: local